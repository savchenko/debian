"
" ----------------------------------------------------------------------------
" System
" ----------------------------------------------------------------------------
"
set ttyfast
set nocompatible
set lazyredraw
set shell=/bin/bash
set modelines=0

" Write swap every second and report CursorHold
set updatetime=1000

set termencoding=utf-8
set encoding=utf8
set fileformat=unix
set clipboard=unnamedplus

" Intendation
filetype indent on
set autoindent
set smartindent

" Menu next to the airline
set wildmenu
set wildmode=longest:full,full
set wildignore+=.git,.hg,.svn
set wildignore+=*.aux,*.out,*.toc
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest,*.rbc,*.class,*.pyc
set wildignore+=*.ai,*.bmp,*.gif,*.ico,*.jpg,*.jpeg,*.png,*.psd,*.webp
set wildignore+=*.avi,*.divx,*.mp4,*.webm,*.mov,*.m2ts,*.mkv,*.vob,*.mpg,*.mpeg
set wildignore+=*.mp3,*.oga,*.ogg,*.wav,*.flac
set wildignore+=*.eot,*.otf,*.ttf,*.woff
set wildignore+=*.doc,*.pdf,*.cbr,*.cbz
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz,*.kgb
set wildignore+=*.swp,.lock,.DS_Store,._*

" Leave it, needed for regexp
set magic

" Window's title (i3 tab for example)
set title

" Enable mouse with tmux 2.4
set mouse=a

" Allow switching buffers w/o saving
set hidden

" Don't join spaces on paste
set nojoinspaces

" Don't autoextend comments or join comment characters
set formatoptions-=r formatoptions-=c formatoptions-=o formatoptions-=j

" Autosaves
if has("unix")
  set backupdir=~/.vim/backup
  set directory=~/.vim/tmp
  set undodir=~/.vim/undo
elseif has("win32")
  let g:nvim_dir = substitute($HOME, '\\', '\\\', "g").'\\AppData\\Local\\nvim\\'
  set backupdir=g:nvim_dir.'backup'
  set directory=g:nvim_dir.'tmp'
  set undodir=g:nvim_dir.'undo'
endif
set backup
set undofile
set noswapfile
set undolevels=1000
set undoreload=10000
set history=1000

" Highlight brackets
set showmatch

" Search is incremental and case-sensitive if UpperCase is present
set ignorecase
set smartcase
set hlsearch
set incsearch

" <TAB> at the ^ equals to 'shiftwidth'
set smarttab

" Round indent to multiple of 'shiftwidth`
set shiftround

" Expand <TAB> into spaces
set expandtab

" reveal already opened files instead of opening new buffers
set switchbuf=useopen,usetab,newtab

" Add space before comments
let NERDSpaceDelims=1

" Don't mess with markdown spaces
let g:whitespace_autostrip=0
let g:whitespace_ignore_splits=0
let g:whitespace_highlight='Error'
let g:whitespace_ignore_tabs = [
            \ 'git',
            \ 'gitcommit',
            \ 'gitconfig',
            \ 'gitrebase',
            \ 'gitsendemail',
            \ ]

" Smart pairs are disabled by default:
let g:pear_tree_smart_openers = 1
let g:pear_tree_smart_closers = 1
let g:pear_tree_smart_backspace = 1

" Load matchit
let loaded_matchit = 1

"
" ----------------------------------------------------------------------------
" Visuals
" ----------------------------------------------------------------------------
"

" Highlight up to 512 chars per line
set synmaxcol=512

if has("termguicolors")
    set termguicolors
else
    set t_Co=256
endif

" BG and italics colour fix for tmux
if &term =~# '^screen'
    set t_ut=
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    set t_ZH=^[[3m
    set t_ZR=^[[23m
endif

" Colorscheme theme
syntax on
let g:github_colors_soft = 1
let g:github_colors_block_diffmark = 1
colorscheme hybrid

" Nice highlight of the current line, turned off by  default
highlight CursorLine cterm=NONE ctermbg=NONE ctermfg=NONE guibg=NONE guifg=NONE
set nocul

" Airline
let g:airline_minimalist_showmod = 0
let g:airline_theme='minimalist'
let g:airline_powerline_fonts=1
let g:airline_skip_empty_sections = 1
let g:airline#parts#ffenc#skip_expected_string='utf-8[unix]'
let g:airline#extensions#tabline#enabled=1
let g:airline#extensions#whitespace#enabled = 0
let g:airline_symbols = {}
let g:airline_symbols.linenr = ''
let g:airline_symbols.maxlinenr = ''
let g:airline_symbols.branch = '⎇ '

function! AirlineInit()
    let g:airline_section_z = airline#section#create('%#__accent_bold#%{zoom#statusline()}%3l%#__restore__#/%L :%3v')
endfunction

autocmd User AirlineAfterInit call AirlineInit()

let g:airline_mode_map = {
            \ '__' : '-',
            \ 'n'  : 'N',
            \ 'i'  : 'I',
            \ 'R'  : 'R',
            \ 'c'  : 'C',
            \ 'v'  : 'V',
            \ 'V'  : 'V',
            \ '' : 'V',
            \ 's'  : 'S',
            \ 'S'  : 'S',
            \ '' : 'S',
            \ }

" Show tabline only if >1 file is open
let g:airline#extensions#tabline#show_buffers=1
let g:airline#extensions#tabline#buffer_min_count=2
let g:airline#extensions#tabline#tab_min_count=2

" Disable buffer type SR
let g:airline#extensions#tabline#show_tab_type=0
let g:airline#extensions#tabline#fnamemod=':t'

" As we already show it in airline..
set noshowmode

" Show typed command in normal mode
set showcmd

" No line numbers by default
set nonumber

" Don't show startup message
set shortmess+=Ic

" Wrap long lines and don't break words
set wrap
set linebreak

" indent wrapped lines, by...
set breakindent
set breakindentopt=shift:2,sbr
set showbreak=↪

" Better vertical split visualization
set fillchars+=vert:\┃

" Natural splits
set splitbelow
set splitright

" Split vertical by default
set diffopt+=vertical

" Disable all bells and don't blink with the cursor
set noerrorbells
set novisualbell
set vb t_vb=
set guicursor=a:blinkon0

" Always show airline
set laststatus=2

" Completion options, don't show preview window with additional information,
" show completion menu even if there is one option available,
" don't insert text until explicitly asked to.
set completeopt-=preview
set completeopt+=menuone
set completeopt+=noinsert,noselect

" Always show SignColumn
set signcolumn=yes

" Prettier GitGutter glyphs
let g:gitgutter_sign_added = '+'
let g:gitgutter_sign_modified = '•'
let g:gitgutter_sign_removed = '-'
let g:gitgutter_sign_removed_first_line = '-'
let g:gitgutter_sign_modified_removed = '~'

" Disable indent line by default
let g:indentLine_enabled = 1
let g:indentLine_setColors = 1
let g:indentLine_char = '┊'
let g:indentLine_leadingSpaceEnabled = 0
let g:indentLine_leadingSpaceChar = '·'

" Change cursor shape
set guicursor=n-v-c:block-Cursor/lCursor-blinkon0,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor

" ...and in VTE
let &t_SI = "\<Esc>[6 q"
let &t_SR = "\<Esc>[4 q"
let &t_EI = "\<Esc>[2 q"

" Invisible characters
set listchars=tab:▸\ ,nbsp:␣,trail:·,eol:¶,space:·,conceal:·

let g:startify_custom_header = [
            \ '┌┬┐┬ ┬┬┌┐┌┬┌─ ',
            \ ' │ ├─┤││││├┴┐ ',
            \ ' ┴ ┴ ┴┴┘└┘┴ ┴o',
            \ ]

let g:startify_lists = [
            \ { 'type': 'files',     'header': ['MRU'] },
            \ ]

"
" ----------------------------------------------------------------------------
" Hotkeys
" ----------------------------------------------------------------------------
"
" F1 does _absolutely_ nothing
nnoremap <F1> <nop>
inoremap <F1> <nop>
map <F1> <nop>

" Tree
nnoremap <F2> :NERDTreeToggle<cr>

" F3 yanks all
map <F3> :%y+<cr>

" Line numbers
map <F4> :set nonumber!<cr>

" Toggle indentation
map <F5> :IndentLinesToggle<cr>

" Toggle invisible chars
map <F6> :set list!<cr>

" Toggle spell-check
map <F7> :set spell!<cr>

" Go back into normal mode by `ii`
inoremap ii <esc>

" Remap leader from `\` to `Space`
let mapleader = "\<Space>"

" <leader>+m toggles "scroll mode"
map <leader>m :call ToggleScrollMode()<cr>

" <leader>+s is ysW
map <leader>s ysW

" Toggle line numbers between absolute/relative
map <S-l> :call ToggleNumber()<cr>

" Save as usual
map <C-s> :w!<CR>
imap <C-s> <Esc>:w!<CR>a

" Close __WINDOW__ as usual
map <C-w> :close<CR>

" Select all as usual (skips to the last symbol)
map <C-a> <esc>gg0vG$<CR>

" Don't copy result of 'dd', 's' and 'c' into buffer
nnoremap d "_d
vnoremap d "_d
nnoremap s "_s
vnoremap s "_s
nnoremap c "_c
vnoremap C "_C

" Move up/down using _visual_ lines (e.g. wrapped ones)
nnoremap j gj
nnoremap k gk
nnoremap <Up> gk
nnoremap <Down> gj

" Move to beginning/end of line
nnoremap B ^
nnoremap E $

" Add new lines and spaces without changing the mode
nmap <Leader>j mvo<Esc>`v
nmap <Leader>k mvO<Esc>`v
nmap <Leader>h i<space><esc>l
nmap <Leader>l a<space><esc>h

" Save is forced by default (don't nag about "file exists")
map :w<cr> :w!<cr>
map :x<cr> :x!<cr>

" cd into file's directory
map <leader>cd :cd %:p:h<cr>:pwd<cr>

" Clear all highlights
nnoremap <esc><esc> :noh<return><esc>

" Don't use Ex mode, exit on QQ
nnoremap Q <nop>
nnoremap QQ ZZ

" Switch splits using Ctrl+hjkl (TODO: use NeoVim's ALT support)
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

" Buffer management
nmap <leader>. :bn<CR>
nmap <leader>, :bp<CR>
nmap <leader>q :bp <BAR> bd #<CR>

" Leave text selected after changing intendation with <>
vnoremap < <gv
vnoremap > >gv

" Move to another line with arrow keys
set whichwrap+=<,>

" Resize splits with +-
if bufwinnr(1)
    map + <C-W>+
    map - <C-W>-
endif

" Move a line of text using Shift+[jk]
nmap <S-j> mz:m+<cr>`z
nmap <S-k> mz:m-2<cr>`z
vmap <S-j> :m'>+<cr>`<my`>mzgv`yo`z
vmap <S-k> :m'<-2<cr>`>my`<mzgv`yo`z

" Don't mess with hotkeys
let g:fuzzy_bindkeys = 0

" Open fzy or rgrep finders
nnoremap <C-f> :FuzzyOpen<CR>
nnoremap <C-g> :FuzzyGrep<CR>

" Git
nnoremap <Leader>hn :GitGutterNextHunk<CR>
nnoremap <Leader>hp :GitGutterPrevHunk<CR>

" Zoom
nmap <Leader>z <Plug>(zoom-toggle)


"
" ----------------------------------------------------------------------------
" Macros
" ----------------------------------------------------------------------------
"

" Mostly use 2 spaces as <Tab>
autocmd FileType text,markdown,vim,ini,gitconfig,*.yml setlocal tabstop=2 shiftwidth=2 softtabstop=2

" Keep Web documents to 2 spaces as <Tab>
autocmd BufRead,BufNewFile *.htm,*.html,*.css,*.js setlocal tabstop=2 shiftwidth=2 softtabstop=2

" Pythonic tabs are limited to *.py
autocmd Filetype python setlocal expandtab tabstop=4 shiftwidth=4 softtabstop=4

" Fix YAML intendation
autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab indentkeys-=<:>

augroup pandoc_syntax
    au! BufNewFile,BufFilePre,BufRead *.md set filetype=markdown.pandoc
augroup END

" Autocomplete
au FileType php setl ofu=phpcomplete#CompletePHP
au FileType ruby,eruby setl ofu=rubycomplete#Complete
au FileType html,xhtml setl ofu=htmlcomplete#CompleteTags
au FileType c setl ofu=ccomplete#CompleteCpp
au FileType css setl ofu=csscomplete#CompleteCSS
autocmd FileType vim let b:vcm_tab_complete = 'vim'

" format JSON code
com! FormatJSON %!python -m json.tool

" Resize splits when VIM is resized
autocmd VimResized * wincmd =

" Close NERDTree if it's the only window left
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" Scroll mode, keeps cursor centered and horizontally unchanged
function! ToggleScrollMode()
    if exists("s:scroll_mode")
        unmap k
        unmap j
        set startofline
        set virtualedit=""
        unlet s:scroll_mode
        echom "scroll mode OFF"
    else
        nnoremap j <C-e>j
        nnoremap k <C-y>k
        set virtualedit=all
        set nostartofline
        let s:scroll_mode = 1
        echom "scroll mode ON"
    endif
endfunction

" Prevent opening files in NERDTree
let g:fzf_layout = { 'window': 'let g:launching_fzf = 1 | keepalt topleft 100split enew' }
autocmd FileType nerdtree let t:nerdtree_winnr = bufwinnr('%')
autocmd BufWinEnter * call PreventBuffersInNERDTree()

function! PreventBuffersInNERDTree()
  if bufname('#') =~ 'NERD_tree' && bufname('%') !~ 'NERD_tree'
    \ && exists('t:nerdtree_winnr') && bufwinnr('%') == t:nerdtree_winnr
    \ && &buftype == '' && !exists('g:launching_fzf')
    let bufnum = bufnr('%')
    close
    exe 'b ' . bufnum
  endif
  if exists('g:launching_fzf') | unlet g:launching_fzf | endif
endfunction

" toggle between number and relativenumber
function! ToggleNumber()
    if(&relativenumber == 1)
        set norelativenumber
        set number
    else
        set relativenumber
    endif
endfunc

" strips trailing whitespace at the end of files.
function! <SID>WhitespaceStrip()
    " save last search & cursor position
    let _s=@/
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    let @/=_s
    call cursor(l, c)
endfunction
